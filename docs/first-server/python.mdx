---
title: "Python"
description: "Create a simple MCP server in Python in 15 minutes"
---

Let's build your first MCP server in Python! We'll create a weather server that provides current weather data as a resource and lets Claude fetch forecasts using tools.

<Note>
  This guide uses the OpenWeatherMap API. You'll need a free API key from [OpenWeatherMap](https://openweathermap.org/api) to follow along.
</Note>

## Prerequisites

<Steps>
  <Step title="Install Python">
    You'll need Python 3.10 or higher:

    ```bash
    python --version  # Should be 3.10 or higher
    pip --version
    ```
  </Step>

  <Step title="Install uv (https://docs.astral.sh/uv/) via homebrew">
    ```bash
    brew install uv
    uv --version # Should be 0.4.18 or higher
    ```
  </Step>

  <Step title="Create a new project">
    ```bash
    mkdir weather-server
    cd weather-server
    uv init --package --app --name weather-server
    source .venv/bin/activate  # activate our virtual environment
    ```
  </Step>

  <Step title="Install dependencies">
    ```bash
    uv add mcp
    ```
  </Step>

  <Step title="Set up environment">
    Create `.env`:

    ```bash
    OPENWEATHER_API_KEY=your-api-key-here
    ```
  </Step>
</Steps>

## Create your server

<Steps>
  <Step title="Create project structure">
    ```bash
    touch weather_server.py
    ```
  </Step>

  <Step title="Add the base code">
  In `weather_server.py`
  ```python
  import os
  import json
  import logging
  from datetime import datetime
  from typing import Any

  import requests
  from dotenv import load_dotenv
  from mcp.server import Server
  from mcp.server.models import InitializationOptions
  from mcp.types import (
      ServerCapabilities,
      ListResourcesResult,
      ReadResourceResult,
      ListToolsResult,
      CallToolResult,
      McpError,
  )

  load_dotenv()

  # Configure logging
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger("weather-server")

  API_KEY = os.getenv("OPENWEATHER_API_KEY")
  if not API_KEY:
      raise ValueError("OPENWEATHER_API_KEY environment variable required")

  API_BASE_URL = "http://api.openweathermap.org/data/2.5"
  DEFAULT_CITY = "San Francisco"
  CURRENT_WEATHER_ENDPOINT = "weather"
  FORECAST_ENDPOINT = "forecast"

  class WeatherServer(Server):
      def __init__(self):
          super().__init__("example-weather-server")

          # Set up HTTP session
          self.http = requests.Session()
          self.http.params = {
              "appid": API_KEY,
              "units": "metric"
          }

      @self.list_resources()
      async def list_resources(self) -> ListResourcesResult:
          # Implementation will come later
          pass

      @self.read_resource()
      async def read_resource(self, uri: str) -> ReadResourceResult:
          # Implementation will come later
          pass

      @self.list_tools()
      async def list_tools(self) -> ListToolsResult:
          # Implementation will come later
          pass

      @self.call_tool()
      async def call_tool(self, name: str, args: Any) -> CallToolResult:
          # Implementation will come later
          pass


  ```
  </Step>

  <Step title="Add resource handlers">
    Add these methods to the `WeatherServer` class:

    ```python
    @self.list_resources()
    async def list_resources(self) -> ListResourcesResult:
        """List available weather resources."""
        return ListResourcesResult(
            resources=[
                Resource(
                    uri=f"weather://{DEFAULT_CITY}/current",
                    name=f"Current weather in {DEFAULT_CITY}",
                    mimeType="application/json",
                    description="Real-time weather data"
                )
            ]
        )

    @self.read_resource()
    async def read_resource(self, uri: AnyUrl) -> ReadResourceResult:
        """Read current weather data for a city."""
        city = DEFAULT_CITY
        if str(uri) != f"weather://{city}/current":
            raise McpError(
                ErrorData(
                    code=INVALID_REQUEST,
                    message=f"Unknown resource: {uri}"
                )
            )

        try:
            response = self.http.get(
                f"{API_BASE_URL}/{CURRENT_WEATHER_ENDPOINT}",
                params={"q": city}
            )
            response.raise_for_status()
            data = response.json()

            weather_data = {
                "temperature": data["main"]["temp"],
                "conditions": data["weather"][0]["description"],
                "humidity": data["main"]["humidity"],
                "wind_speed": data["wind"]["speed"],
                "timestamp": datetime.now().isoformat()
            }

            return ReadResourceResult(
                contents=[
                    TextResourceContents(
                        uri=uri,
                        mimeType="application/json",
                        text=json.dumps(weather_data, indent=2)
                    )
                ]
            )
        except requests.RequestException as e:
            raise McpError(
                ErrorData(
                    code=INTERNAL_ERROR,
                    message=f"Weather API error: {str(e)}"
                )
            )
    ```
  </Step>

  <Step title="Add tool handlers">
    Add these methods to the `WeatherServer` class:

    ```python
    @self.list_tools()
    async def list_tools(self) -> ListToolsResult:
        """List available weather tools."""
        return ListToolsResult(
            tools=[
                Tool(
                    name="get_forecast",
                    description="Get weather forecast for a city",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "city": {
                                "type": "string",
                                "description": "City name"
                            },
                            "days": {
                                "type": "number",
                                "description": "Number of days (1-5)",
                                "minimum": 1,
                                "maximum": 5
                            }
                        },
                        "required": ["city"]
                    }
                )
            ]
        )

    @self.call_tool()
    async def call_tool(self, name: str, arguments: Any) -> CallToolResult:
        """Handle tool calls for weather forecasts."""
        if name != "get_forecast":
            raise McpError(
                ErrorData(
                    code=METHOD_NOT_FOUND,
                    message=f"Unknown tool: {name}"
                )
            )

        if not isinstance(arguments, dict) or "city" not in arguments:
            raise McpError(
                ErrorData(
                    code=INVALID_PARAMS,
                    message="Invalid forecast arguments"
                )
            )

        city = arguments["city"]
        days = min(int(arguments.get("days", 3)), 5)

        try:
            response = self.session.get(
                f"{API_BASE_URL}/{FORECAST_ENDPOINT}",
                params={
                    "q": city,
                    "cnt": days * 8  # API returns 3-hour intervals
                }
            )
            response.raise_for_status()
            data = response.json()

            forecasts = []
            for i in range(0, len(data["list"]), 8):
                day_data = data["list"][i]
                forecasts.append({
                    "date": day_data["dt_txt"].split()[0],
                    "temperature": day_data["main"]["temp"],
                    "conditions": day_data["weather"][0]["description"]
                })

            return CallToolResult(
                content=[
                    TextContent(
                        type="text",
                        text=json.dumps(forecasts, indent=2)
                    )
                ],
                isError=False
            )
        except requests.RequestException as e:
            raise McpError(
                ErrorData(
                    code=INTERNAL_ERROR,
                    message=f"Weather API error: {str(e)}"
                )
            )
    ```
  </Step>

  <Step title="Add the main entry point">
    Add this to the end of `weather_server.py`:

    ```python
   async def main():
      server = WeatherServer()

      # Import here to avoid issues with event loops
      from mcp.server.stdio import stdio_server

      async with stdio_server() as (read_stream, write_stream):
          await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
          )

  if __name__ == "__main__":
      import anyio
      anyio.run(main)
    ```
  </Step>

</Steps>

## Understanding the code

<Tabs>
  <Tab title="Type Hints">
    ```python
    async def read_resource(self, uri: str) -> ReadResourceResult:
        # ...
    ```

    Python type hints help catch errors early and improve code maintainability.
  </Tab>

  <Tab title="Resources">
    ```python
    @self.list_resources()
    async def list_resources(self) -> ListResourcesResult:
        return ListResourcesResult(
            resources=[
                Resource(
                    uri=f"weather://{DEFAULT_CITY}/current",
                    name=f"Current weather in {DEFAULT_CITY}",
                    mimeType="application/json",
                    description="Real-time weather data"
                )
            ]
        )
    ```

    Resources provide data that Claude can access as context.
  </Tab>

  <Tab title="Tools">
    ```python
    Tool(
        name="get_forecast",
        description="Get weather forecast for a city",
        inputSchema={
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "City name"
                },
                "days": {
                    "type": "number",
                    "description": "Number of days (1-5)",
                    "minimum": 1,
                    "maximum": 5
                }
            },
            "required": ["city"]
        }
    )
    ```

    Tools let Claude take actions through your server with validated inputs.
  </Tab>
</Tabs>

## Best practices

<CardGroup cols={1}>
  <Card title="Error Handling" icon="shield">
    ```python
    try:
        response = self.http.get(...)
        response.raise_for_status()
    except requests.RequestException as e:
        raise McpError(
            ErrorCode.INTERNAL_ERROR,
            f"API error: {str(e)}"
        )
    ```
  </Card>

  <Card title="Type Validation" icon="check">
    ```python
    if not isinstance(args, dict) or "city" not in args:
        raise McpError(
            ErrorCode.INVALID_PARAMS,
            "Invalid forecast arguments"
        )
    ```
  </Card>

  <Card title="Environment Variables" icon="gear">
    ```python
    if not API_KEY:
        raise ValueError("OPENWEATHER_API_KEY is required")
    ```
  </Card>

</CardGroup>

## Available transports

While this guide uses stdio transport, MCP supports additonal transport options:

### SSE (Server-Sent Events)

```python
from modelcontextprotocol import SSEServerTransport
transport = SSEServerTransport("/events", response)
```

## Troubleshooting

### Installation issues

```bash
# Check Python version
python --version

# Reinstall dependencies
uv sync --reinstall

# Ensure we are using the right virtual environment
source .venv/bin/activate
```

### Runtime errors

```bash
# Enable debug logging
export MCP_LOG_LEVEL=DEBUG
python weather_server.py
```

### Type checking

```bash
# Install mypy
uv add --dev pyright

# Run type checker
pyright src
```

## Connect to Claude Desktop

<Steps>
  <Step title="Update Claude config">
    Add to `claude_desktop_config.json`:

    ```json
    {
      "mcpServers": {
        "weather": {
          "command": "uv",
          "args": "--directory path/to/your/project run weather-service",
          "env": {
            "OPENWEATHER_API_KEY": "your-api-key",
          }
        }
      }
    }
    ```
  </Step>

  <Step title="Restart Claude">
    1. Quit Claude completely

    2. Start Claude again

    3. Look for your weather server in the 🔌 menu
  </Step>
</Steps>

## Try it out!

<AccordionGroup>
  <Accordion title="Check Current Weather" active>
    Ask Claude:

    ```
    What's the current weather in San Francisco? Can you analyze the conditions and tell me if it's a good day for outdoor activities?
    ```
  </Accordion>

  <Accordion title="Get a Forecast">
    Ask Claude:

    ```
    Can you get me a 5-day forecast for Tokyo and help me plan what clothes to pack for my trip?
    ```
  </Accordion>

  <Accordion title="Compare Weather">
    Ask Claude:

    ```
    Can you analyze the forecast for both Tokyo and San Francisco and tell me which city would be better for outdoor photography this week?
    ```
  </Accordion>
</AccordionGroup>

## Advanced features

<Steps>
  <Step title="Add caching">
    ```python
    from functools import lru_cache
    from datetime import datetime, timedelta

    class WeatherServer:
        def __init__(self):
            self._cache_timeout = timedelta(minutes=15)
            self._last_cache_time = None
            self._cached_weather = None

        @lru_cache(maxsize=32)
        async def _fetch_weather(self, city: str) -> Dict[str, Any]:
            # Cache expires after 15 minutes
            now = datetime.now()
            if (self._cached_weather is None or
                self._last_cache_time is None or
                now - self._last_cache_time > self._cache_timeout):

                response = self.session.get(...)
                self._cached_weather = response.json()
                self._last_cache_time = now

            return self._cached_weather
    ```
  </Step>

  <Step title="Add progress notifications">
    ```python
    @self.call_tool()
    async def call_tool(self, name: str, arguments: Any) -> CallToolResult:
        if progress_token := self.request_context.meta.progressToken:
            # Send progress notifications
            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=1,
                total=2
            )

            # Fetch data...

            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=2,
                total=2
            )

        # Rest of the method implementation...
    ```
  </Step>

  <Step title="Add logging support">
    ```python
    import logging

    class WeatherServer(Server):
        def __init__(self):
            super().__init__("example-weather-server")
            self.logger = logging.getLogger("weather-server")
            self.logger.setLevel(logging.INFO)

        @self.set_logging_level()
        async def set_logging_level(self, level: LoggingLevel) -> EmptyResult:
            self.logger.setLevel(level.upper())
            await self.request_context.session.send_log_message(
                level="info",
                data=f"Log level set to {level}",
                logger="weather-server"
            )
            return EmptyResult()

        # Use self.logger for logging throughout the class methods
        # For example:
        # self.logger.info("Weather data fetched successfully")
        # self.logger.error(f"Error fetching weather data: {str(e)}")
    ```
  </Step>

  <Step title="Add resource templates">
    ```python
    @self.list_resources()
    async def list_resources(self) -> ListResourcesResult:
        return ListResourcesResult(
            resources=[...],
            resourceTemplates=[
                ResourceTemplate(
                    uriTemplate="weather://{city}/current",
                    name="Current weather for any city",
                    mimeType="application/json"
                )
            ]
        )
    ```
  </Step>
</Steps>

## Testing

<Steps>
  <Step title="Create test file">
  Create `src/weather_service/tests/test_weather_server.py`:

  ```python
  import pytest
  from unittest.mock import Mock, patch
  from weather_service.weather_server import WeatherServer

  @pytest.fixture
  async def server():
      server = WeatherServer()
      yield server

  @pytest.mark.asyncio
  async def test_list_resources(server):
      result = await server.list_resources()
      assert len(result.resources) > 0
      assert result.resources[0].mimeType == "application/json"

  @pytest.mark.asyncio
  async def test_get_forecast():
      with patch("requests.Session") as mock_session:
          mock_session.return_value.get.return_value.json.return_value = {
              "list": [{
                  "dt_txt": "2024-01-01 12:00:00",
                  "main": {"temp": 20},
                  "weather": [{"description": "sunny"}]
              }]
          }

          server = WeatherServer()
          result = await server.call_tool("get_forecast", {"city": "Tokyo", "days": 1})
          assert len(result.content) == 1
          assert "temperature" in result.content[0].text
          assert "20" in result.content[0].text
  ```
  </Step>
  <Step title="Run tests">
  ```bash
  uv add --dev pytest pytest-asyncio
  uv run pytest src/weather_service/
  ```
  </Step>
</Steps>

## Next steps

<CardGroup cols={2}>
  <Card title="Architecture overview" icon="sitemap" href="/docs/concepts/architecture">
    Learn more about the MCP architecture
  </Card>

  <Card title="Python SDK" icon="python" href="/api-reference/python/class-reference">
    Read more about the Python SDK
  </Card>
</CardGroup>
